


http://pramode.net/clojure/2010/05/26/creating-objects-in-clojure/

(defn student []
  (let [name (atom nil)
	age  (atom nil)
	
	set (fn [n a]
	      (do (reset! name n)
		  (reset! age a)))

	
	get (fn [] [@name @age])]


    (fn [m]
      (cond (= m :set) set
	    (= m :get) get))))






http://thinkrelevance.com/blog/2013/11/07/when-should-you-use-clojures-object-oriented-features

(defprotocol IMarshaller
  (marshall   [_ data] "Marshall data, return a ByteBuffer ready to transmit.")
  (unmarshall [_ bbuf] "Unmarshall data from the ByteBuffer"))

(deftype EdnMarshaller []
  IMarshaller
  (marshall   [_ data] (io/clj->bbuf data))
  (unmarshall [_ bbuf] (io/bbuf->clj bbuf)))

(defn edn-marshaller [] (EdnMarshaller.))


(defn edn-marshaller [] 
  (reify IMarshaller
    (marshall   [_ data] (io/clj->bbuf data))
    (unmarshall [_ bbuf] (io/bbuf->clj bbuf))))






https://dzone.com/articles/object-oriented-clojure

(defprotocol Position
    (description  [this])
    (translateX   [this dx])
    (translateY   [this dy])
    (doubleCoords [this])
    (average      [this another]))

(defrecord CartesianPoint [x y]
    Position
        (description    [this]      (str "(x=" x ", y=" y ")"))
        (translateX     [this dx]   (CartesianPoint.    (+ x dx)
                                                        y))
        (translateY     [this dy]   (CartesianPoint.    x
                                                        (+ y dy)))
        (doubleCoords   [this]      (CartesianPoint.    (* 2 x)
                                                        (* 2 y)))
        (average        [this another]
                        (let [mean (fn [a b] (/ (+ a b) 2))]
                             (CartesianPoint. (mean x (:x another))
                                              (mean y (:y another))))))






https://gist.github.com/runexec/786b92b97b5a3a0ffac7

user> (defprotocol IABC
        (also-oo [this])
        (another-fn [this x]))
IABC


user> (defrecord ABC [name]
        ;; You can implement multiple Classes here
        IABC
        (also-oo [this]
          (str "This => " (:name this)))
        (another-fn [this x]
          (format "%s says: %s" (:name this) x)))
user.ABC


user> (def a (ABC. "Roger"))
#'user/a
user> (another-fn a "oo programing")
"Roger says: oo programing"
user> (also-oo a)
"This => Roger"


user> (defmulti this-is-oo type)
nil
user> (defmethod this-is-oo ABC [this]
        (println (:name this)))
#<MultiFn clojure.lang.MultiFn@8625d0e>
user> (this-is-oo a)
Roger
user> (defmethod this-is-oo java.lang.String [this]
        "Got a string and not ABC!!!!")
#<MultiFn clojure.lang.MultiFn@8625d0e>
user> (this-is-oo "a")
"Got a string and not ABC!!!!"








(defn create-connection
  [...]
  (let [resource (...)]
    (fn [arg]
      (condp =
        :close (.close resource)
        ...
        (.send resource arg)))))

(defn close
  [conn]
  (conn :close))

(...
  (let [c (create-connection ...)]
    (c "my data")
    (close c))




(defn create-connection
  [...]
  (let [resource (...)]
    {:send (fn [arg] (.send resource arg))
     :close (fn [] (.close resource))
     ...}))

(defn send
  [conn arg]
  ((conn :send) arg))

(defn close
  [conn]
  ((conn :close)))

(...
  (let [c (create-connection ...)]
    (send c "my data")
    (close c))






